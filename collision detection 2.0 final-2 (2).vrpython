{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode import *\n\ndrivetrain = Drivetrain()\nmagnet = Electromagnet(\"magnet\", 0)\npen = Pen()\nbrain = Brain()\nleft_bumper = Bumper(\"leftBumper\", 1)\nright_bumper = Bumper(\"rightBumper\", 2)\ndistance = Distance()\nfront_eye = EyeSensor(\"fronteye\", 3)\ndown_eye = EyeSensor(\"downeye\", 4)\nlocation = Location()\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      Collision Detection 2.0\n#\tAuthor:       Jeremy Stout\n#\tCreated:      1/7/2022\n#\tDescription:  VEXcode VR Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vexcode import *\n\n# Add project code in \"main\"\ndef main():\n    drivetrain.drive_for(FORWARD, 800, MM)\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    drivetrain.drive_for(FORWARD, 1000, MM)\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    #this sends the robot to the starting location\n    pen.move(DOWN)\n    locaty = 0\n    locatx = 0\n    maze = [\n        [0,0,0,0,0,0,0],\n    \t[0,1,1,0,0,0,0],\n    \t[0,0,1,1,0,0,0],\n    \t[0,0,0,1,1,0,0],\n        [0,0,0,0,1,1,0],\n        [0,0,0,0,0,3,0],\n        [0,0,0,0,0,0,0]\n    ]\n    location_detection(maze, locatx, locaty)\n\ndef location_detection(maze, locatx, locaty):\n    x = location.position(X, MM)\n    y = location.position(Y, MM)\n    locatx = round(abs(x)/100)\n    locaty = round(abs(y)/100)\n    wait(50, MSEC)\n    obstacle_detection(maze, locaty, locatx)\n    #this function detects the position of the robot and applies it to a grid position\n\ndef obstacle_detection(maze, locaty, locatx):\n    pos1 = maze[locaty-1][locatx-1]\n    pos2 = maze[locaty-1][locatx]\n    pos3 = maze[locaty-1][locatx+1]\n    pos4 = maze[locaty][locatx+1]\n    pos5 = maze[locaty + 1][locatx+1]\n    pos6 = maze[locaty+1][locatx]\n    pos7 = maze[locaty+1][locatx-1]\n    pos8 = maze[locaty][locatx-1]\n    if maze[locaty][locatx] != 3:\n        brain.print(\"1: %d; 2: %d; 3: %d; 4: %d; 5: %d; 6: %d; 7: %d; 8: %d\" %(pos1, pos2, pos3, pos4, pos5, pos6, pos7, pos8))\n        brain.new_line()\n    wait(50, MSEC)\n    obstacle_avoidance(pos1, pos2, pos3, pos4, pos5, pos6, pos7, pos8, locatx, locaty, maze)\n    #pos1 is the location above and to the left of the robot, the other positions go in clockwise order until pos8 which is to the left of the robot\n\ndef obstacle_avoidance(pos1, pos2, pos3, pos4, pos5, pos6, pos7, pos8, locatx, locaty, maze):\n    #this tells the robot how to move around the course\n    if maze[locaty][locatx] == 1 and locatx <= 5 and locatx >= 0 and locaty <= 5 and locaty >= 0:\n        if drivetrain.heading(DEGREES) == 0:\n            if pos2 == 3:\n                drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n                stop_project()\n            elif pos2 == 0:\n                if pos4 == 1 or pos4 == 3:\n                    if pos3 == 1 or pos3 == 3:\n                        drivetrain.turn_for(RIGHT, 45, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 142, MM, wait=True)\n                        drivetrain.turn_for(LEFT, 45, DEGREES, wait=True)\n                    else:\n                        drivetrain.turn_for(RIGHT, 90, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n                elif pos8 == 1 or pos8 == 3:\n                    if pos1 == 1 or pos1 == 3:\n                        drivetrain.turn_for(LEFT, 45, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 142, MM, wait=True)\n                        drivetrain.turn_for(RIGHT, 45, DEGREES, wait=True)\n                    else:\n                        drivetrain.turn_for(LEFT, 90, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n                else:\n                    drivetrain.turn_for(RIGHT, 180, DEGREES)\n            elif pos2 == 1:\n                drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n        elif drivetrain.heading(DEGREES) == 90:\n            if pos4 == 3:\n                drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n                stop_project()\n            elif pos4 == 0:\n                if pos6 == 1 or pos6 == 3:\n                    if pos5 == 1 or pos5 == 3:\n                        drivetrain.turn_for(RIGHT, 45, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 142, MM, wait=True)\n                        drivetrain.turn_for(LEFT, 45, DEGREES, wait=True)\n                    else:\n                        drivetrain.turn_for(RIGHT, 90, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n                elif pos2 == 1 or pos2 == 3:\n                    if pos3 == 1 or pos3 == 3:\n                        drivetrain.turn_for(LEFT, 45, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 142, MM, wait=True)\n                        drivetrain.turn_for(RIGHT, 45, DEGREES, wait=True)\n                    else:\n                        drivetrain.turn_for(LEFT, 90, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n                else:\n                    drivetrain.turn_for(RIGHT, 180, DEGREES)\n            elif pos4 == 1:\n                drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n        elif drivetrain.heading(DEGREES) == 180:\n            if pos6 == 3:\n                drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n                stop_project()\n            elif pos6 == 0:\n                if pos4 == 1 or pos4 == 3:\n                    if pos5 == 1 or pos5 == 3:\n                        drivetrain.turn_for(LEFT, 45, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 142, MM, wait=True)\n                        drivetrain.turn_for(RIGHT, 45, DEGREES, wait=True)\n                    else:\n                        drivetrain.turn_for(LEFT, 90, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n                elif pos8 == 1 or pos8 == 3:\n                    if pos7 == 1 or pos7 == 3:\n                        drivetrain.turn_for(RIGHT, 45, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 142, MM, wait=True)\n                        drivetrain.turn_for(LEFT, 45, DEGREES, wait=True)\n                    else:\n                        drivetrain.turn_for(RIGHT, 90, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n                else:\n                    drivetrain.turn_for(RIGHT, 180, DEGREES)\n            elif pos6 == 1:\n                drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n        elif drivetrain.heading(DEGREES) == 270:\n            if pos8 == 3:\n                drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n                stop_project()\n            elif pos8 == 0:\n                if pos6 == 1 or pos6 == 3:\n                    if po7 == 1 or pos7 == 3:\n                        drivetrain.turn_for(LEFT, 45, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 142, MM, wait=True)\n                        drivetrain.turn_for(RIGHT, 45, DEGREES, wait=True)\n                    else:\n                        drivetrain.turn_for(LEFT, 90, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n                elif pos2 == 1 or pos2 == 3:\n                    if pos1 == 1 or pos1 == 3:\n                        drivetrain.turn_for(RIGHT, 45, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 142, MM, wait=True)\n                        drivetrain.turn_for(LEFT, 45, DEGREES, wait=True)\n                    else:\n                        drivetrain.turn_for(RIGHT, 90, DEGREES, wait=True)\n                        drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n                else:\n                    drivetrain.turn_for(RIGHT, 180, DEGREES)\n            elif pos8 == 1:\n                drivetrain.drive_for(FORWARD, 100, MM, wait=True)\n    elif maze[locaty][locatx] == 3:\n        stop_project()\n\n    wait(50, MSEC)\n    location_detection(maze, locaty, locatx)\n\n# VR threads â€” Do not delete\nvr_thread(main())\n","textLanguage":"python","rconfig":[],"slot":0,"platform":"PG","sdkVersion":"20211013.15.00.00","appVersion":"2.2.1","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","playground":"Grid","robotModel":"vr","target":"Physical"}